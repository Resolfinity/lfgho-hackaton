// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {IGhoToken} from "./interfaces/IGhoToken.sol";
import {IVerifier} from "./interfaces/IVerifier.sol";
import {IETHOracle} from "./interfaces/IETHOracle.sol";

import "hardhat/console.sol";

contract ZkBucketManager {
    IGhoToken public GHOL2Token;
    IVerifier verifier;
    IETHOracle public ethSrorageRootOracle;
    address public l2FlashMinterFacilitator;

    constructor(
        address _wGHOToken,
        address _verifier,
        address _ethSrorageRootOracle,
        address _l2FlashMinterFacilitator
    ) {
        GHOL2Token = IGhoToken(_wGHOToken);
        verifier = IVerifier(_verifier);
        ethSrorageRootOracle = IETHOracle(_ethSrorageRootOracle);
        l2FlashMinterFacilitator = _l2FlashMinterFacilitator;
    }

    function splitBytes32(bytes32 input) internal pure returns (bytes32[] memory) {
        bytes32[] memory byteArray = new bytes32[](32);

        assembly {
            // Iterate over each byte in the input
            for { let i := 0 } lt(i, 32) { i := add(i, 1) } {
                // Shift right to align the current byte to the rightmost position
                // and mask it to isolate the byte
                let shiftedByte := and(shr(mul(8, sub(31, i)), input), 0xff)

                // Store the isolated byte in the bytes32 slot
                mstore(add(byteArray, add(32, mul(i, 32))), shiftedByte)
            }
        }

        return byteArray;
    }

    function updateBucketCap(bytes calldata _proof, bytes32 _storageRoot, uint256 _bucketCapValue) external {
        // first we have to verify that the storage root of eth block is stored in the oracle contract of the current chain
        // since it is out of scope of our project, we hardcode true response
        // btw, our team is working on the ZK full eth2 consensus proof platrorm,
        // which will allowe to use eth headers crosschain, fully trustless
        // follow our progress here: https://github.com/resolfinity/

        // bool isStorageRootStored = ethBlockHashOracle.isStorageRootStored(ethBlockHash);

        bool isStorageRootStored = true;
        require(isStorageRootStored, "storage root is not stored in the oracle");

        // then we verify the proof, which is generated by the circuit
        // _publicInputs consists of 2 elements - eth blockhash and the value of FlashMinter facilitator bucket
        // from the mainnet GHO contract

        // we have to pass _publicInputs into veririer.verify function as bytes32 array, where each byte is a bytes32 element
        // it is a strange noir verifier implementation, we have to follow it
        // todo: research how to pass fields into noir circuit, not [u8; 32]

        bytes32[] memory publicInputs = new bytes32[](64);

        bytes32[] memory storageRootAsBytes = splitBytes32(_storageRoot);
        bytes32[] memory bucketCapValueAsBytes = splitBytes32(bytes32(_bucketCapValue));

        for (uint256 i = 0; i < 32; i++) {
            publicInputs[i] = storageRootAsBytes[i];
            publicInputs[i + 32] = bucketCapValueAsBytes[i];
        }

        // for (uint256 i = 0; i < 64; i++) {
        //     console.logBytes32(publicInputs[i]);
        // }

        verifier.verify(_proof, publicInputs);

        GHOL2Token.setFacilitatorBucketCapacity(l2FlashMinterFacilitator, uint128(_bucketCapValue));
    }
}
